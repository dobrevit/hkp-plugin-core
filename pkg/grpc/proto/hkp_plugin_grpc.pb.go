// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/hkp_plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HKPPlugin_Initialize_FullMethodName        = "/hkpplugin.HKPPlugin/Initialize"
	HKPPlugin_Shutdown_FullMethodName          = "/hkpplugin.HKPPlugin/Shutdown"
	HKPPlugin_GetInfo_FullMethodName           = "/hkpplugin.HKPPlugin/GetInfo"
	HKPPlugin_HandleHTTPRequest_FullMethodName = "/hkpplugin.HKPPlugin/HandleHTTPRequest"
	HKPPlugin_HandleKeyChange_FullMethodName   = "/hkpplugin.HKPPlugin/HandleKeyChange"
	HKPPlugin_SubscribeEvents_FullMethodName   = "/hkpplugin.HKPPlugin/SubscribeEvents"
	HKPPlugin_PublishEvent_FullMethodName      = "/hkpplugin.HKPPlugin/PublishEvent"
	HKPPlugin_QueryStorage_FullMethodName      = "/hkpplugin.HKPPlugin/QueryStorage"
	HKPPlugin_HealthCheck_FullMethodName       = "/hkpplugin.HKPPlugin/HealthCheck"
	HKPPlugin_CheckRateLimit_FullMethodName    = "/hkpplugin.HKPPlugin/CheckRateLimit"
	HKPPlugin_ReportThreat_FullMethodName      = "/hkpplugin.HKPPlugin/ReportThreat"
)

// HKPPluginClient is the client API for HKPPlugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The main plugin service
type HKPPluginClient interface {
	// Lifecycle management
	Initialize(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Plugin information
	GetInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginInfo, error)
	// HTTP middleware
	HandleHTTPRequest(ctx context.Context, in *HTTPRequest, opts ...grpc.CallOption) (*HTTPResponse, error)
	// Event handling
	HandleKeyChange(ctx context.Context, in *KeyChangeEvent, opts ...grpc.CallOption) (*Event, error)
	SubscribeEvents(ctx context.Context, in *EventFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error)
	PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
	// Storage access (proxied)
	QueryStorage(ctx context.Context, in *StorageQuery, opts ...grpc.CallOption) (*StorageResponse, error)
	// Health monitoring
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthStatus, error)
	// Rate limiting
	CheckRateLimit(ctx context.Context, in *RateLimitCheck, opts ...grpc.CallOption) (*RateLimitResponse, error)
	// Threat detection
	ReportThreat(ctx context.Context, in *ThreatInfo, opts ...grpc.CallOption) (*Empty, error)
}

type hKPPluginClient struct {
	cc grpc.ClientConnInterface
}

func NewHKPPluginClient(cc grpc.ClientConnInterface) HKPPluginClient {
	return &hKPPluginClient{cc}
}

func (c *hKPPluginClient) Initialize(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitResponse)
	err := c.cc.Invoke(ctx, HKPPlugin_Initialize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShutdownResponse)
	err := c.cc.Invoke(ctx, HKPPlugin_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) GetInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginInfo)
	err := c.cc.Invoke(ctx, HKPPlugin_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) HandleHTTPRequest(ctx context.Context, in *HTTPRequest, opts ...grpc.CallOption) (*HTTPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPResponse)
	err := c.cc.Invoke(ctx, HKPPlugin_HandleHTTPRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) HandleKeyChange(ctx context.Context, in *KeyChangeEvent, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, HKPPlugin_HandleKeyChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) SubscribeEvents(ctx context.Context, in *EventFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HKPPlugin_ServiceDesc.Streams[0], HKPPlugin_SubscribeEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EventFilter, Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HKPPlugin_SubscribeEventsClient = grpc.ServerStreamingClient[Event]

func (c *hKPPluginClient) PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, HKPPlugin_PublishEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) QueryStorage(ctx context.Context, in *StorageQuery, opts ...grpc.CallOption) (*StorageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StorageResponse)
	err := c.cc.Invoke(ctx, HKPPlugin_QueryStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthStatus)
	err := c.cc.Invoke(ctx, HKPPlugin_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) CheckRateLimit(ctx context.Context, in *RateLimitCheck, opts ...grpc.CallOption) (*RateLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitResponse)
	err := c.cc.Invoke(ctx, HKPPlugin_CheckRateLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hKPPluginClient) ReportThreat(ctx context.Context, in *ThreatInfo, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, HKPPlugin_ReportThreat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HKPPluginServer is the server API for HKPPlugin service.
// All implementations must embed UnimplementedHKPPluginServer
// for forward compatibility.
//
// The main plugin service
type HKPPluginServer interface {
	// Lifecycle management
	Initialize(context.Context, *InitRequest) (*InitResponse, error)
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Plugin information
	GetInfo(context.Context, *Empty) (*PluginInfo, error)
	// HTTP middleware
	HandleHTTPRequest(context.Context, *HTTPRequest) (*HTTPResponse, error)
	// Event handling
	HandleKeyChange(context.Context, *KeyChangeEvent) (*Event, error)
	SubscribeEvents(*EventFilter, grpc.ServerStreamingServer[Event]) error
	PublishEvent(context.Context, *Event) (*Empty, error)
	// Storage access (proxied)
	QueryStorage(context.Context, *StorageQuery) (*StorageResponse, error)
	// Health monitoring
	HealthCheck(context.Context, *Empty) (*HealthStatus, error)
	// Rate limiting
	CheckRateLimit(context.Context, *RateLimitCheck) (*RateLimitResponse, error)
	// Threat detection
	ReportThreat(context.Context, *ThreatInfo) (*Empty, error)
	mustEmbedUnimplementedHKPPluginServer()
}

// UnimplementedHKPPluginServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHKPPluginServer struct{}

func (UnimplementedHKPPluginServer) Initialize(context.Context, *InitRequest) (*InitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedHKPPluginServer) Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedHKPPluginServer) GetInfo(context.Context, *Empty) (*PluginInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedHKPPluginServer) HandleHTTPRequest(context.Context, *HTTPRequest) (*HTTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleHTTPRequest not implemented")
}
func (UnimplementedHKPPluginServer) HandleKeyChange(context.Context, *KeyChangeEvent) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleKeyChange not implemented")
}
func (UnimplementedHKPPluginServer) SubscribeEvents(*EventFilter, grpc.ServerStreamingServer[Event]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeEvents not implemented")
}
func (UnimplementedHKPPluginServer) PublishEvent(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishEvent not implemented")
}
func (UnimplementedHKPPluginServer) QueryStorage(context.Context, *StorageQuery) (*StorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStorage not implemented")
}
func (UnimplementedHKPPluginServer) HealthCheck(context.Context, *Empty) (*HealthStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHKPPluginServer) CheckRateLimit(context.Context, *RateLimitCheck) (*RateLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRateLimit not implemented")
}
func (UnimplementedHKPPluginServer) ReportThreat(context.Context, *ThreatInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportThreat not implemented")
}
func (UnimplementedHKPPluginServer) mustEmbedUnimplementedHKPPluginServer() {}
func (UnimplementedHKPPluginServer) testEmbeddedByValue()                   {}

// UnsafeHKPPluginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HKPPluginServer will
// result in compilation errors.
type UnsafeHKPPluginServer interface {
	mustEmbedUnimplementedHKPPluginServer()
}

func RegisterHKPPluginServer(s grpc.ServiceRegistrar, srv HKPPluginServer) {
	// If the following call pancis, it indicates UnimplementedHKPPluginServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HKPPlugin_ServiceDesc, srv)
}

func _HKPPlugin_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_Initialize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).Initialize(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).GetInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_HandleHTTPRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).HandleHTTPRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_HandleHTTPRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).HandleHTTPRequest(ctx, req.(*HTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_HandleKeyChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyChangeEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).HandleKeyChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_HandleKeyChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).HandleKeyChange(ctx, req.(*KeyChangeEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_SubscribeEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HKPPluginServer).SubscribeEvents(m, &grpc.GenericServerStream[EventFilter, Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HKPPlugin_SubscribeEventsServer = grpc.ServerStreamingServer[Event]

func _HKPPlugin_PublishEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).PublishEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_PublishEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).PublishEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_QueryStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).QueryStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_QueryStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).QueryStorage(ctx, req.(*StorageQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_CheckRateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateLimitCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).CheckRateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_CheckRateLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).CheckRateLimit(ctx, req.(*RateLimitCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _HKPPlugin_ReportThreat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThreatInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HKPPluginServer).ReportThreat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HKPPlugin_ReportThreat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HKPPluginServer).ReportThreat(ctx, req.(*ThreatInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// HKPPlugin_ServiceDesc is the grpc.ServiceDesc for HKPPlugin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HKPPlugin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hkpplugin.HKPPlugin",
	HandlerType: (*HKPPluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _HKPPlugin_Initialize_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _HKPPlugin_Shutdown_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _HKPPlugin_GetInfo_Handler,
		},
		{
			MethodName: "HandleHTTPRequest",
			Handler:    _HKPPlugin_HandleHTTPRequest_Handler,
		},
		{
			MethodName: "HandleKeyChange",
			Handler:    _HKPPlugin_HandleKeyChange_Handler,
		},
		{
			MethodName: "PublishEvent",
			Handler:    _HKPPlugin_PublishEvent_Handler,
		},
		{
			MethodName: "QueryStorage",
			Handler:    _HKPPlugin_QueryStorage_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _HKPPlugin_HealthCheck_Handler,
		},
		{
			MethodName: "CheckRateLimit",
			Handler:    _HKPPlugin_CheckRateLimit_Handler,
		},
		{
			MethodName: "ReportThreat",
			Handler:    _HKPPlugin_ReportThreat_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeEvents",
			Handler:       _HKPPlugin_SubscribeEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/hkp_plugin.proto",
}

const (
	PluginHost_GetHostInfo_FullMethodName    = "/hkpplugin.PluginHost/GetHostInfo"
	PluginHost_RequestStorage_FullMethodName = "/hkpplugin.PluginHost/RequestStorage"
	PluginHost_PublishEvent_FullMethodName   = "/hkpplugin.PluginHost/PublishEvent"
	PluginHost_QueryPlugin_FullMethodName    = "/hkpplugin.PluginHost/QueryPlugin"
)

// PluginHostClient is the client API for PluginHost service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Optional: Bidirectional communication service for plugins
type PluginHostClient interface {
	// Plugins can query host for information
	GetHostInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HostInfo, error)
	// Plugins can request storage operations
	RequestStorage(ctx context.Context, in *StorageQuery, opts ...grpc.CallOption) (*StorageResponse, error)
	// Plugins can publish events to other plugins
	PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
	// Plugins can query other plugins
	QueryPlugin(ctx context.Context, in *PluginQuery, opts ...grpc.CallOption) (*PluginResponse, error)
}

type pluginHostClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginHostClient(cc grpc.ClientConnInterface) PluginHostClient {
	return &pluginHostClient{cc}
}

func (c *pluginHostClient) GetHostInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HostInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HostInfo)
	err := c.cc.Invoke(ctx, PluginHost_GetHostInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHostClient) RequestStorage(ctx context.Context, in *StorageQuery, opts ...grpc.CallOption) (*StorageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StorageResponse)
	err := c.cc.Invoke(ctx, PluginHost_RequestStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHostClient) PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, PluginHost_PublishEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHostClient) QueryPlugin(ctx context.Context, in *PluginQuery, opts ...grpc.CallOption) (*PluginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginResponse)
	err := c.cc.Invoke(ctx, PluginHost_QueryPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginHostServer is the server API for PluginHost service.
// All implementations must embed UnimplementedPluginHostServer
// for forward compatibility.
//
// Optional: Bidirectional communication service for plugins
type PluginHostServer interface {
	// Plugins can query host for information
	GetHostInfo(context.Context, *Empty) (*HostInfo, error)
	// Plugins can request storage operations
	RequestStorage(context.Context, *StorageQuery) (*StorageResponse, error)
	// Plugins can publish events to other plugins
	PublishEvent(context.Context, *Event) (*Empty, error)
	// Plugins can query other plugins
	QueryPlugin(context.Context, *PluginQuery) (*PluginResponse, error)
	mustEmbedUnimplementedPluginHostServer()
}

// UnimplementedPluginHostServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginHostServer struct{}

func (UnimplementedPluginHostServer) GetHostInfo(context.Context, *Empty) (*HostInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostInfo not implemented")
}
func (UnimplementedPluginHostServer) RequestStorage(context.Context, *StorageQuery) (*StorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestStorage not implemented")
}
func (UnimplementedPluginHostServer) PublishEvent(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishEvent not implemented")
}
func (UnimplementedPluginHostServer) QueryPlugin(context.Context, *PluginQuery) (*PluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPlugin not implemented")
}
func (UnimplementedPluginHostServer) mustEmbedUnimplementedPluginHostServer() {}
func (UnimplementedPluginHostServer) testEmbeddedByValue()                    {}

// UnsafePluginHostServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginHostServer will
// result in compilation errors.
type UnsafePluginHostServer interface {
	mustEmbedUnimplementedPluginHostServer()
}

func RegisterPluginHostServer(s grpc.ServiceRegistrar, srv PluginHostServer) {
	// If the following call pancis, it indicates UnimplementedPluginHostServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginHost_ServiceDesc, srv)
}

func _PluginHost_GetHostInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHostServer).GetHostInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHost_GetHostInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHostServer).GetHostInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHost_RequestStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHostServer).RequestStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHost_RequestStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHostServer).RequestStorage(ctx, req.(*StorageQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHost_PublishEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHostServer).PublishEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHost_PublishEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHostServer).PublishEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHost_QueryPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHostServer).QueryPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHost_QueryPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHostServer).QueryPlugin(ctx, req.(*PluginQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginHost_ServiceDesc is the grpc.ServiceDesc for PluginHost service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginHost_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hkpplugin.PluginHost",
	HandlerType: (*PluginHostServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHostInfo",
			Handler:    _PluginHost_GetHostInfo_Handler,
		},
		{
			MethodName: "RequestStorage",
			Handler:    _PluginHost_RequestStorage_Handler,
		},
		{
			MethodName: "PublishEvent",
			Handler:    _PluginHost_PublishEvent_Handler,
		},
		{
			MethodName: "QueryPlugin",
			Handler:    _PluginHost_QueryPlugin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/hkp_plugin.proto",
}
