// Tarpit components for defensive connection management
package main

import (
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/dobrevit/hkp-plugin-core/pkg/grpc/proto"
)

// Tarpit implements the tarpit functionality
type Tarpit struct {
	config    *TarpitConfig
	delayMin  time.Duration
	delayMax  time.Duration
	chunkSize int
}

func NewTarpit(config *TarpitConfig) *Tarpit {
	delayMin, _ := time.ParseDuration(config.DelayMin)
	delayMax, _ := time.ParseDuration(config.DelayMax)

	return &Tarpit{
		config:    config,
		delayMin:  delayMin,
		delayMax:  delayMax,
		chunkSize: config.ResponseChunkSize,
	}
}

func (t *Tarpit) GenerateTarpitResponse(connInfo *ConnectionInfo) []byte {
	// Generate fake response data based on tarpit mode
	response := t.generateFakeData()

	// Apply resource exhaustion if enabled
	if t.config.ResourceExhaustion.Enabled {
		t.applyResourceExhaustion(connInfo)
	}

	return response
}

func (t *Tarpit) calculateDelay(connInfo *ConnectionInfo) time.Duration {
	switch t.config.TarpitMode {
	case "slow":
		// Gradually increase delay
		factor := float64(connInfo.DelaysApplied) / 10.0
		delay := t.delayMin + time.Duration(factor*float64(t.delayMax-t.delayMin))
		if delay > t.delayMax {
			delay = t.delayMax
		}
		return delay

	case "sticky":
		// Keep connection open with minimal data
		return t.delayMax

	case "random":
		// Random delays to confuse attackers
		r := rand.Float64()
		return t.delayMin + time.Duration(r*float64(t.delayMax-t.delayMin))

	default:
		return t.delayMin
	}
}

func (t *Tarpit) generateFakeData() []byte {
	// Generate plausible but useless data
	templates := []string{
		"Processing request...\n",
		"Loading data...\n",
		"Please wait while we process your request...\n",
		"Fetching results...\n",
		"Almost done...\n",
		"Just a moment more...\n",
		"Connecting to database...\n",
		"Validating credentials...\n",
		"Checking permissions...\n",
		"Loading configuration...\n",
	}

	// Build response
	var response strings.Builder
	
	// Add some initial processing message
	response.WriteString("Processing your request...\n\n")

	// Add random content to make it look real
	contentSize := t.config.ResourceExhaustion.FakeDataSize
	if contentSize == 0 {
		contentSize = 1024
	}

	for response.Len() < contentSize {
		template := templates[rand.Intn(len(templates))]
		response.WriteString(template)

		// Add some random data occasionally
		if rand.Float64() < 0.3 {
			response.WriteString(fmt.Sprintf("<!-- %s -->\n", generateRandomString(20)))
		}

		// Add fake progress
		if rand.Float64() < 0.2 {
			progress := rand.Intn(100)
			response.WriteString(fmt.Sprintf("Progress: %d%%\n", progress))
		}
	}

	response.WriteString("\n<!-- Generated by tarpit system -->\n")
	return []byte(response.String())
}

func (t *Tarpit) applyResourceExhaustion(connInfo *ConnectionInfo) {
	if t.config.ResourceExhaustion.CPUIntensive {
		// Perform CPU-intensive operations
		go func() {
			result := 1
			for i := 0; i < 10000; i++ {
				result = result * i % 1000000
			}
			_ = result
		}()
	}

	if t.config.ResourceExhaustion.MemoryIntensive {
		// Allocate temporary memory
		data := make([]byte, 1024*1024) // 1MB
		rand.Read(data)
		// Let it be garbage collected
		_ = data
	}
}

// Honeypot implements honeypot functionality
type Honeypot struct {
	paths    map[string]bool
	trapData map[string]HoneypotTrap
	mu       sync.RWMutex
}

type HoneypotTrap struct {
	Path       string
	TrapType   string // fake_admin, fake_api, fake_vuln
	Response   string
	StatusCode int
	Headers    map[string]string
}

func NewHoneypot(paths []string) *Honeypot {
	h := &Honeypot{
		paths:    make(map[string]bool),
		trapData: make(map[string]HoneypotTrap),
	}

	// Default honeypot paths if none specified
	if len(paths) == 0 {
		paths = []string{
			"/admin", "/wp-admin", "/.git", "/.env",
			"/phpmyadmin", "/api/v1/users", "/backup.sql",
			"/config.php", "/database.sql", "/admin.php",
		}
	}

	// Initialize traps
	for _, path := range paths {
		h.paths[path] = true
		h.trapData[path] = h.generateTrap(path)
	}

	return h
}

func (h *Honeypot) IsHoneypotPath(path string) bool {
	h.mu.RLock()
	defer h.mu.RUnlock()

	return h.paths[path]
}

func (h *Honeypot) GetTrap(path string) HoneypotTrap {
	h.mu.RLock()
	defer h.mu.RUnlock()

	if trap, exists := h.trapData[path]; exists {
		return trap
	}

	// Generate default trap
	return h.generateTrap(path)
}

func (h *Honeypot) generateTrap(path string) HoneypotTrap {
	trap := HoneypotTrap{
		Path:    path,
		Headers: make(map[string]string),
	}

	// Generate trap based on path
	switch {
	case strings.Contains(path, "admin"):
		trap.TrapType = "fake_admin"
		trap.StatusCode = 200
		trap.Response = generateFakeAdminPage()
		trap.Headers["Content-Type"] = "text/html"

	case strings.Contains(path, ".git"):
		trap.TrapType = "fake_git"
		trap.StatusCode = 403
		trap.Response = "Forbidden: Access denied to .git directory"

	case strings.Contains(path, "api"):
		trap.TrapType = "fake_api"
		trap.StatusCode = 200
		trap.Response = `{"error": "API endpoint not found", "version": "1.0", "status": "maintenance"}`
		trap.Headers["Content-Type"] = "application/json"

	case strings.Contains(path, ".env"):
		trap.TrapType = "fake_env"
		trap.StatusCode = 200
		trap.Response = generateFakeEnvFile()
		trap.Headers["Content-Type"] = "text/plain"

	case strings.Contains(path, "phpmyadmin"):
		trap.TrapType = "fake_phpmyadmin"
		trap.StatusCode = 200
		trap.Response = generateFakePhpMyAdminPage()
		trap.Headers["Content-Type"] = "text/html"

	default:
		trap.TrapType = "generic"
		trap.StatusCode = 404
		trap.Response = "Not Found"
	}

	return trap
}

// ConnectionManager manages active tarpit connections
type ConnectionManager struct {
	connections map[string]*ConnectionInfo
	maxActive   int
	mu          sync.RWMutex
}

func NewConnectionManager(maxActive int) *ConnectionManager {
	return &ConnectionManager{
		connections: make(map[string]*ConnectionInfo),
		maxActive:   maxActive,
	}
}

func (cm *ConnectionManager) AddConnection(clientIP string, reason string) *ConnectionInfo {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	// Check if already exists
	if conn, exists := cm.connections[clientIP]; exists {
		conn.Reason = reason // Update reason
		return conn
	}

	// Check capacity
	if len(cm.connections) >= cm.maxActive {
		// Remove oldest connection
		cm.removeOldest()
	}

	conn := &ConnectionInfo{
		ClientIP:    clientIP,
		ConnectedAt: time.Now(),
		State:       "active",
		Reason:      reason,
	}

	cm.connections[clientIP] = conn
	return conn
}

func (cm *ConnectionManager) GetConnection(clientIP string) *ConnectionInfo {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	return cm.connections[clientIP]
}

func (cm *ConnectionManager) GetActiveCount() int {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	return len(cm.connections)
}

func (cm *ConnectionManager) removeOldest() {
	var oldestIP string
	var oldestTime time.Time

	for ip, conn := range cm.connections {
		if oldestIP == "" || conn.ConnectedAt.Before(oldestTime) {
			oldestIP = ip
			oldestTime = conn.ConnectedAt
		}
	}

	if oldestIP != "" {
		delete(cm.connections, oldestIP)
	}
}

func (cm *ConnectionManager) DrainAll() {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	for _, conn := range cm.connections {
		conn.State = "draining"
	}
}

// IntelligenceCollector gathers attacker intelligence
type IntelligenceCollector struct {
	intelligence map[string]*AttackerProfile
	patterns     []PatternDetector
	mu           sync.RWMutex
}

type AttackerProfile struct {
	IP             string
	FirstSeen      time.Time
	LastSeen       time.Time
	Requests       int
	Techniques     map[string]int
	Tools          map[string]bool
	Persistence    int
	Sophistication string
}

type PatternDetector struct {
	Name     string
	Pattern  string
	Category string // tool, technique, behavior
}

func NewIntelligenceCollector() *IntelligenceCollector {
	ic := &IntelligenceCollector{
		intelligence: make(map[string]*AttackerProfile),
	}

	// Initialize pattern detectors
	ic.patterns = []PatternDetector{
		{Name: "Nikto", Pattern: "nikto", Category: "tool"},
		{Name: "SQLMap", Pattern: "sqlmap", Category: "tool"},
		{Name: "Nmap", Pattern: "nmap", Category: "tool"},
		{Name: "DirBuster", Pattern: "dirbuster", Category: "tool"},
		{Name: "Gobuster", Pattern: "gobuster", Category: "tool"},
		{Name: "Wfuzz", Pattern: "wfuzz", Category: "tool"},
		{Name: "SQL Injection", Pattern: "union.*select", Category: "technique"},
		{Name: "XSS", Pattern: "<script>", Category: "technique"},
		{Name: "Path Traversal", Pattern: "../", Category: "technique"},
		{Name: "Command Injection", Pattern: ";cat ", Category: "technique"},
	}

	return ic
}

func (ic *IntelligenceCollector) AnalyzeRequest(clientIP string, req *proto.HTTPRequest, connInfo *ConnectionInfo) {
	ic.mu.Lock()
	defer ic.mu.Unlock()

	profile, exists := ic.intelligence[clientIP]
	if !exists {
		profile = &AttackerProfile{
			IP:         clientIP,
			FirstSeen:  time.Now(),
			Techniques: make(map[string]int),
			Tools:      make(map[string]bool),
		}
		ic.intelligence[clientIP] = profile
	}

	profile.LastSeen = time.Now()
	profile.Requests++

	// Analyze for patterns
	userAgent := req.Headers["User-Agent"]
	urlPath := req.Path

	for _, detector := range ic.patterns {
		if strings.Contains(strings.ToLower(userAgent), detector.Pattern) ||
			strings.Contains(strings.ToLower(urlPath), detector.Pattern) {

			switch detector.Category {
			case "tool":
				profile.Tools[detector.Name] = true
			case "technique":
				profile.Techniques[detector.Name]++
			}
		}
	}

	// Update sophistication
	profile.Sophistication = ic.calculateSophistication(profile)

	// Update connection info
	connInfo.Intelligence = AttackerIntelligence{
		Tools:          ic.getTools(profile),
		Techniques:     ic.getTechniques(profile),
		Persistence:    profile.Persistence,
		Sophistication: profile.Sophistication,
	}
}

func (ic *IntelligenceCollector) calculateSophistication(profile *AttackerProfile) string {
	score := 0

	// More tools = higher sophistication
	score += len(profile.Tools) * 10

	// More techniques = higher sophistication
	score += len(profile.Techniques) * 15

	// Persistence adds to sophistication
	if profile.Requests > 100 {
		score += 20
	} else if profile.Requests > 50 {
		score += 10
	}

	switch {
	case score < 20:
		return "low"
	case score < 50:
		return "medium"
	default:
		return "high"
	}
}

func (ic *IntelligenceCollector) getTools(profile *AttackerProfile) []string {
	tools := make([]string, 0, len(profile.Tools))
	for tool := range profile.Tools {
		tools = append(tools, tool)
	}
	return tools
}

func (ic *IntelligenceCollector) getTechniques(profile *AttackerProfile) []string {
	techniques := make([]string, 0, len(profile.Techniques))
	for technique := range profile.Techniques {
		techniques = append(techniques, technique)
	}
	return techniques
}

// TarpitMetrics tracks tarpit and honeypot metrics
type TarpitMetrics struct {
	tarpittedConnections int64
	honeypotAccesses     int64
	autoTarpits          int64
	intelligenceGathered int64
	bytesSent            int64
	tarpitsByReason      map[string]int64
	honeypotsByPath      map[string]int64
	mu                   sync.RWMutex
}

func NewTarpitMetrics() *TarpitMetrics {
	return &TarpitMetrics{
		tarpitsByReason: make(map[string]int64),
		honeypotsByPath: make(map[string]int64),
	}
}

func (tm *TarpitMetrics) RecordTarpit(clientIP string, reason string) {
	atomic.AddInt64(&tm.tarpittedConnections, 1)

	tm.mu.Lock()
	tm.tarpitsByReason[reason]++
	tm.mu.Unlock()
}

func (tm *TarpitMetrics) RecordHoneypotAccess(clientIP string, path string) {
	atomic.AddInt64(&tm.honeypotAccesses, 1)

	tm.mu.Lock()
	tm.honeypotsByPath[path]++
	tm.mu.Unlock()
}

func (tm *TarpitMetrics) RecordAutoTarpit(clientIP string, score float64) {
	atomic.AddInt64(&tm.autoTarpits, 1)
}

func (tm *TarpitMetrics) RecordIntelligence() {
	atomic.AddInt64(&tm.intelligenceGathered, 1)
}

func (tm *TarpitMetrics) RecordBytesSent(bytes int64) {
	atomic.AddInt64(&tm.bytesSent, bytes)
}

func (tm *TarpitMetrics) GetTarpittedCount() int64 {
	return atomic.LoadInt64(&tm.tarpittedConnections)
}

func (tm *TarpitMetrics) GetHoneypotCount() int64 {
	return atomic.LoadInt64(&tm.honeypotAccesses)
}

func (tm *TarpitMetrics) GetAutoTarpitCount() int64 {
	return atomic.LoadInt64(&tm.autoTarpits)
}

// Utility functions

func generateRandomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

func generateHoneyToken() string {
	// Generate a tracking token
	return fmt.Sprintf("HT-%s-%d", generateRandomString(8), time.Now().Unix())
}

func generateFakeAdminPage() string {
	return `<!DOCTYPE html>
<html>
<head>
    <title>Admin Login</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 50px; }
        .login-form { max-width: 400px; margin: 0 auto; padding: 20px; border: 1px solid #ccc; }
        input { width: 100%; padding: 10px; margin: 10px 0; }
        .submit-btn { background: #007cba; color: white; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div class="login-form">
        <h1>Administrator Login</h1>
        <form method="post" action="/admin/login">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <input type="submit" value="Login" class="submit-btn">
        </form>
        <p><small>Version 2.1.4 - ` + generateRandomString(8) + `</small></p>
    </div>
    <!-- Session ID: ` + generateRandomString(32) + ` -->
</body>
</html>`
}

func generateFakeEnvFile() string {
	return `# Environment Configuration
APP_NAME=MyApp
APP_ENV=production
APP_KEY=base64:` + generateRandomString(32) + `
APP_DEBUG=false
APP_URL=http://localhost

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=myapp_db
DB_USERNAME=admin
DB_PASSWORD=` + generateRandomString(16) + `

CACHE_DRIVER=file
SESSION_DRIVER=file
QUEUE_DRIVER=sync

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_DRIVER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null

# API Keys
API_KEY=` + generateRandomString(40) + `
SECRET_KEY=` + generateRandomString(64) + `
`
}

func generateFakePhpMyAdminPage() string {
	return `<!DOCTYPE html>
<html>
<head>
    <title>phpMyAdmin</title>
    <style>
        body { font-family: sans-serif; margin: 0; background: #f8f9fa; }
        .header { background: #2c3e50; color: white; padding: 10px; }
        .content { padding: 20px; }
        .login-form { background: white; padding: 20px; border-radius: 5px; max-width: 400px; margin: 20px auto; }
        input { width: 100%; padding: 8px; margin: 5px 0; border: 1px solid #ddd; }
        .btn { background: #3498db; color: white; padding: 10px 20px; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div class="header">
        <h2>phpMyAdmin 4.9.7</h2>
    </div>
    <div class="content">
        <div class="login-form">
            <h3>Welcome to phpMyAdmin</h3>
            <form method="post">
                <label>Server:</label>
                <select><option>localhost</option></select>
                <label>Username:</label>
                <input type="text" name="pma_username" autocomplete="off">
                <label>Password:</label>
                <input type="password" name="pma_password" autocomplete="off">
                <br><br>
                <input type="submit" value="Go" class="btn">
            </form>
        </div>
    </div>
    <!-- Build: ` + generateRandomString(10) + ` -->
</body>
</html>`
}